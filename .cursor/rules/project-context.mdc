---
description: プロジェクトの長期的なコンテキストと制約
alwaysApply: true
---

# プロジェクトのコンテキスト（常に意識すべき前提）

このファイルは、**すべての実装・判断時に参照すべき、プロジェクトの長期的なコンテキスト**を定義します。

## プロジェクトの真の目的

### 最上位の目的
**「毎日ブログを書くためのネタ探しを自動化する実用的なツール」**

- 毎日使う実用ツールであり、実験的なプロジェクトではない
- 「完璧」より「使える」ことを優先
- 動作することが最優先、過度な最適化は後回し

### この目的から派生する原則
1. **実用性重視** - 理論的に正しいより、実際に動くことが重要
2. **継続的な改善** - 完璧を目指さず、使いながら改善
3. **自動化の徹底** - 手動作業を最小限にする

## セキュリティとベストプラクティスの制約

**制約は目的を達成するための「ガードレール」である。回避するものではなく、理解して従うもの。**

### 1. 機密情報の保護（最重要）

#### 制約の意図
- APIキーや認証情報の漏洩を防ぐ
- セキュリティインシデントを未然に防ぐ
- プロジェクトの信頼性を守る

#### 具体的なルール
| ファイル/データ | Gitに含める？ | 理由 |
|---------------|--------------|------|
| `.env` | ❌ **絶対NO** | 機密情報が含まれる |
| `.env.local` | ❌ **絶対NO** | 個人環境の機密情報 |
| `.env.example` | ✅ YES | テンプレート（値は空） |
| `*-*.json` (Google Service Account等) | ❌ **絶対NO** | 認証情報ファイル |
| `package*.json` | ✅ YES | 依存関係の管理に必要 |

#### この制約を破ると何が起きるか？
- APIキーが漏洩し、不正利用される
- プロジェクトが停止する可能性がある
- 金銭的な損害が発生する可能性がある

#### GitHub Push Protectionとは
- GitHubが機密情報の漏洩を防ぐために提供している仕組み
- 機密情報を検出すると、pushをブロックする
- **このエラーが出た場合、権限を与えてpushするのではなく、機密情報を除外する**

### 2. Git管理のベストプラクティス

#### 制約の意図
- プロジェクトの履歴を管理可能に保つ
- チーム開発を円滑にする
- デプロイメントの信頼性を高める

#### 具体的なルール
- ビルド成果物は含めない（`.next/`, `/out/`, `/build/`）
- 依存関係は含めない（`/node_modules/`）
- ローカル環境固有のファイルは含めない（`.DS_Store`, `.wrangler/`）
- 一時ファイルは含めない（`*.log`, `*.db`, `*.db-shm`, `*.db-wal`）

### 3. Cloudflare Pages + D1の制約

#### 制約の意図
- サーバーレス環境で動作させる
- コストを最小化する
- スケーラビリティを確保する

#### 具体的なルール
- すべてのデータベース操作は非同期（`await`必須）
- D1データベースは`request.env`から取得
- マイグレーションは`wrangler d1 migrations apply`で実行
- 環境変数はCloudflareダッシュボードで設定

## 各操作前に確認すべきコンテキスト

### ファイルを削除する前
- [ ] このファイルは何のために存在するのか？
- [ ] 削除することで、何が失われるのか？
- [ ] Gitから削除すべきか、ローカルからも削除すべきか？
- [ ] `.gitignore`で無視すべきファイルか？

### 環境変数や認証情報を扱う前
- [ ] このファイルは機密情報を含むか？
- [ ] Gitに含めるべきファイルか？
- [ ] `.gitignore`で無視されているか？
- [ ] 既にGit履歴に含まれていないか？

### エラーが発生した時
- [ ] このエラーは何を守るために出ているのか？
- [ ] エラーを回避することで、何を失うのか？
- [ ] 根本的な原因は何か？
- [ ] 一時的な回避ではなく、根本的な解決になっているか？

### 外部サービスと連携する時
- [ ] APIキーや認証情報はどこに保存すべきか？
- [ ] レート制限はあるか？
- [ ] エラーハンドリングは適切か？
- [ ] タイムアウト設定は適切か？

### データベースを操作する時
- [ ] 非同期操作になっているか？（`await`を使用）
- [ ] D1データベースは`request.env`から取得しているか？
- [ ] エラーハンドリングは適切か？
- [ ] インデックスを考慮しているか？

## 意思決定の優先順位

**複数の選択肢がある場合、以下の優先順位で判断する：**

1. **セキュリティ** - 機密情報の保護は最優先
2. **実用性** - 実際に動くことが重要
3. **ベストプラクティス** - 一般的な慣習に従う
4. **パフォーマンス** - 最適化は後回し
5. **完璧さ** - 完璧を目指さない

## 「立ち止まって考える」べきタイミング

以下の場合は、**必ず立ち止まって、長期的なコンテキストを確認する：**

1. **エラーが発生した時**
   - エラーを消すことが目的ではない
   - 根本原因を理解し、適切に対応する

2. **環境変数や認証情報を扱う時**
   - セキュリティは最優先
   - Gitに含めるべきかを必ず確認

3. **ファイルを削除する時**
   - 削除の影響範囲を確認
   - Gitから削除すべきか、ローカルからも削除すべきかを判断

4. **セキュリティに関わる操作をする時**
   - 権限を緩めることは最後の手段
   - 制約の意図を理解してから判断

5. **ユーザーの要求が不明確な時**
   - 表面的な言葉ではなく、真の意図を理解
   - 必要であれば、状況を説明して確認

## まとめ：常に意識すべきこと

**すべての実装・判断時に、以下を自問自答する：**

1. **長期的な目的** - このプロジェクトの真の目的は何か？
2. **制約の意図** - この制約は何を守るために存在するのか？
3. **ベストプラクティス** - 一般的な解決方法は何か？
4. **根本的な解決** - 一時的な回避ではなく、根本的な解決になっているか？
5. **セキュリティ** - 機密情報は適切に保護されているか？

**短期的な目的（エラーを消す）ではなく、長期的な目的（システムを正しく動かす）を常に意識すること。**
